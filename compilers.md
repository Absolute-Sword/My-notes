## 解释器

并不通过翻译生成目标程序（也进行翻译，但是并不生成程序），读取用户的输入执行源程序

### 编译器

将源语言编写的程序等价地翻译为目标语言编写的程序

编译器翻译后的程序（一般指机器语言程序）执行速度更快，但是解释器debug更方便（逐个执行源程序）（编译器不是逐个执行吗）

java语言处理器就包括编译和翻译，首先将java程序编译为字节码，然后接收输入，在虚拟机上执行，字节码的优点在于可以在不同的机器上运行，实现迁移

### 预处理器

用来将多个源程序聚合，并将宏的缩写转换为源语言

### 汇编器

处理由编译器生成的汇编语言程序（可能生成汇编而已），并生成可重定位机器代码

### 链接器

用来解决外部内存地址（一个文件中可能会指向外部文件中的位置的情况）

### 加载器

用于把所有可执行文件放到内存中执行

## 编译器的结构

### 分析部分（前端）

将源程序分解为多个组成要素，并加上语法结构，还会检查语法是否正确，生成中间代码表示形式，还后收集源程序信息生成符号表，将符号表和中间表示形式一起传给综合部分

### 代码优化（可选）

在中间表示形式上进行优化，提高代码质量

### 综合部分（后端）

根据传入的两个部分构造目标程序

### 步骤

编译过程本质就是一组步骤

指从一种表示方式到另一种表示方式这个过程

符号表可由编译器各个步骤使用

## 分析部分的具体过程

### 词法分析

对字符流进行解析,将每个子字符串分配到对应的标识类(变量名, 数字, 关键字, 空格, 运算符(比方说括号, 分号, 等号这些标点符号通常属于单独的一个标识类, == 属于运算符)), 每一个子字符串称为词素(lexemes), 此时词法分析把字符流转换为有意义的词素序列，并输出格式为<抽象符号(标识类)，符号表中的索引/ 原始字符串>的词法单元

第二个元素指的是该词法单元的属性值，对于同一类型(名字)的词素,翻译的时候就需要通过属性值来区分,但是不一定每个词法单元都有,对于一些关键字,通过名字或者运算符或者标点符号就可以进行区分,此时就没有属性值

在词法分析分配标识类时, 常常需要面对子字符串具有歧义的情况, 此时需要向前看(lookahead), 通过结合更多的字符来进行判断, 通常向前看字符是需要尽可能少的, 保证运行效率

```pl1
declare [arg1, arg2, ... argn]
```

对于pl1语言, 其特性是关键字不保留, 对于这种情况, 我们无法确定declare是数组名字还是用来声明的 关键字, 不得不扫描整个n个参数 

```c++
stream >> var
template<template<example>> 
```

对于流控制符 >> 容易和嵌套模板中的>>混淆, 通过将">>" 改为"> >''可解决

```fortran
Do 5 l = 1,25 (1)
Do 5 l = 1.25 (2)
```

在fortan中, 空格是会被忽略的, 在example中, 1式会被认定为是一个循环头部(5作为循环体尾部的位置标识符, l从1循环到25),而2式会被认定为 Do5l = 1.25, 即为一个赋值表达式, 因此需要lookahead查看是否存在逗号

如果有错误的字符例如 fi (x==9), 此时词法分析器仍然会将fi分类为标识符,并传给语法分析器,由语法分析器来纠错

当没有模式可以匹配当前输入的字符串前缀时,就会进入"恐慌模式",此时会一直删除输入的字符串直到有前缀与模式匹配上

还有其他的技术可以使用比如说:

从输入中删除一个字符

向输入中插入一个字符

用一个字符替换另一个字符

交换两个相邻的字符

一般的策略就都是像这样看能不能通过一次变换进行纠正,还有例如尝试直接将源程序变换为只包含合法词素的程序,后者使用代价较高所以较少使用



#### 正则表达式

串即是一个由字母表中有穷个字符构成的字符序列

语言即是由字母表中的字符构成的串的集合

空串是连接操作中的单位运算符

c = {"c"} 表达任何字符

$\epsilon$ = {""} 空字符串

Union A +B = {a| a $\in$ A } U {b } $\in$ B} 两个集合的并集

Concatenation AB = {ab | a $\in$ A b $\in$ B } 笛卡尔积

Iteration A* = $\sum\limits_{i>=0} A^i$ 是正则中的*匹配n个A

1* = "" +  1 + 11 + 111 == 111....

(1+0) 1 = {ab| a $\in$ 1+0  b $\in$ 1} = {11, 10}

(0+1)* = "" + (0+1) + (0+1)(0+1)  + ... 可表示任何长度的由0,1 组成的字符串

#### 形式语言

语言是字母表(字符集)所能构成的所有串的集合的一个子集

#### mean function

作用就是将表达式(语法)映射到集合(语义)上

不同的形式语言可能会有相同的语义效果, 多对1

A+ = A A* 至少需要A出现一次

letter : [a-zA-Z]

whitespace ' ' '\b' '\t'

#### 语法规则

只包含一个整数的字符串Integer : "0"+"1"+"2"+"3"....

包含多个数字的字符串: Integer Integer$^*$ 等价于 Integer$^+$

单个字母 letter: [a-zA-Z]

标识符(字符开头,包含数字和字母) : letter (letter + Integer)$^*$ 

"\n" "\t" " " 分别用来表示换行, tab符和空格

pascal 中数字的定义

![image-20201006155707281](/home/yuki/.config/Typora/typora-user-images/image-20201006155707281.png)



词法单元的词法类别是标识符时,如果标识符是字符串则值为编码的对应地址,如果是常数,则值为其自身指的二进制形式,如果是关键字则值为内部整数编码或串编码

使用状态转移图来表示词法的识别过程

将每一类的状态转移图的初始状态与初态0连接起来即能得到一个简易语言的状态转移图

有限自动机是对状态转换图进一步形式化的结果

#### 确定的有限自动机 DFA

$M = (S, \Sigma , f, S_0 F)$ 

S是一个非空有限集,每个元素为一个状态

$\Sigma$为有限的输入字母表,每个元素为一个输入字符,状态转换图中每一条弧上的字符

f是转换函数,$S * \Sigma$到S的单值部分映射,描述了状态间的关系

$S_0\in S$ 唯一的初始状态

$F \in S$ 中止状态的集合

如果DFA的初态节点又是终态节点,则说明空串可被该DFA接受

若$a \in \Sigma^* f(S,a)=p$则a是一个被某DFA接受的字符串,其中p为终止状态集

一个DFA m所能识别的所有字符串全体称为DFA m所能接受的语言,记为L(m)



#### 不确定的有限自动机 NFA

如果存在一条为空串的弧则是NFA

与DFA有区别的是:

f 是 $S * \Sigma^* 到 2^s$的子集的映像 $2^s$是S的子集

$S_0$ 是一个非空的初始状态集

对于任何两个有限自动机M和$M'$,如果L(M)=L($M'$),则M和M'等价

#### 状态的转换

基本思想是让DFA的每个状态代表NFA的一个状态集合

#### 最小化

目的是使L(M) = L(M'),且M'的状态数不多于M的状态数

从开始状态出发,不能到达的状态为多余状态

如果到达某个状态后,无法到达终止状态则称为死状态

多余状态和死状态统称无关状态

若$S_i$为一个状态,则能导出的所有状态集合记为L($S_i$),若两个状态$S_i和S_i,有L(S_i) = S_j$则两状态等价

或者同是终态或同是非终态,也能推出两状态等价

如果两状态不等价,则称为可区别状态,终态和非终态就是可区别

1. $\pi=(s-z, z)$先将状态集进行划分,z是终态,s-z是非终态
2. 将$\pi$根据接受同一个输入字符导出状态的不同划分为多个组
3. 合并等价状态
4. 删除无关状态,删除后需将原来的弧连至保留下来的代表状态



### 语法分析

使用生成的词法单元的第一个分量来创建树形的中间表示形式，用来表示词法单元间的语法结构

树中每个非叶节点代表一个运算，每个叶节点代表一个计算分量

### 语义分析

用来检查源程序是否和语言定义的语义一致，同时也收集类型信息放进符号表或语法树中，以便以后的中间代码生成使用

其中一个重要组成部分是类型检查

### 中间代码生成

为了易于生成同时需要轻松地翻译为目标机器上的语言，通常编译器都会生成一个明确的低级的或类机器语言的表示形式。

此处，考虑三地址代码，每个指令都具有三个运算（或少于三个）分量

### 中间代码生成

使目标代码减少能耗或者更短

### 代码生成

为程序中的每个变量分配寄存器或内存位置

运行时刻的存储组织方式依赖于被编译的语言

### 符号表

收集了包括变量的类型，作用域，函数的参数数量，类型，和参数的传递方法（值传递/引用传递）和返回类型

符号表允许快速存放和获取记录中的数据

### 趟

多个步骤组合成一个趟

同一个前端可以和不同的后端相组合，同理不同前端也可以和一个后端相组合

### 代码优化

数据流优化，用来减少构造之间的亢余

过程内联技术，用来跨越源程序中的过程边界进行优化

## 体系结构的优化

编译器可以用来评价一个正在开发的计算机体系结构，现代计算机体系结构中，编译器在处理器设计阶段就进行开发，将编译得到代码在体系结构上运行就可以评价体系结构好坏

### 并行性

多个运算被同时执行或者是同一个程序的不同线程在不同的处理器上运行

由硬件或者编译器，改变指令顺序，提高程序并行性

### 内存层次结构

寄存器 高速缓存 物理寄存器 外部存储器， 存储大小逐增，访问速度逐减

离处理器越近的存储结构大小越小，改变数据访问代码的顺序或者数据布局来提高内存层次结构的效率

### RISC

简单指令集

对于RISC，编译器能够更加有效地利用它们

### CISC

复杂指令集

## 程序设计语言

如果编译器静态决定问题，就是静态策略，动态决定问题，就是动态策略

如果阅读程序就可以知道声明的作用域，该语言就是静态作用域

反之就是动态作用域，运行时同一个对x的使用会指向x的几个声明中的一个

### 环境

从名字到存储位置的映射

### 状态

从存储位置到值的映射

一般环境和状态都是动态的，但是有两个特殊情况：

1. 全局变量，名字到位置是固定的，编译器会给它们分配虚拟内存位置，程序装载器和操作系统再决定分配到物理内存的哪个地方hg

2. 宏定义，位置到值是固定的

### 参数传递机制

#### 值传递

#### 引用传递

如果是一个表达式，那么他会先表达式求值，然后把值存到一个地址上，之后在函数中改变的是该地址上的值，而不是原始变量

一般，对于数组，字符串以及其他数据结构都用的引用传递

#### 名调用

大致就是把形参作为实参的宏定义



